// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"github.com/hashicorp/vault/api"
	"sync"
)

var (
	lockVaultLogicalAPIMockRead  sync.RWMutex
	lockVaultLogicalAPIMockWrite sync.RWMutex
)

// Ensure, that VaultLogicalAPIMock does implement VaultLogicalAPI.
// If this is not the case, regenerate this file with moq.
var _ VaultLogicalAPI = &VaultLogicalAPIMock{}

// VaultLogicalAPIMock is a mock implementation of VaultLogicalAPI.
//
//func TestSomethingThatUsesVaultLogicalAPI(t *testing.T) {
//
//	// make and configure a mocked VaultLogicalAPI
//	mockedVaultLogicalAPI := &VaultLogicalAPIMock{
//		ReadFunc: func(path string) (*api.Secret, error) {
//			panic("mock out the Read method")
//		},
//		WriteFunc: func(path string, data map[string]interface{}) (*api.Secret, error) {
//			panic("mock out the Write method")
//		},
//	}
//
//	// use mockedVaultLogicalAPI in code that requires VaultLogicalAPI
//	// and then make assertions.
//
//}
type VaultLogicalAPIMock struct {
	// ReadFunc mocks the Read method.
	ReadFunc func(path string) (*api.Secret, error)

	// WriteFunc mocks the Write method.
	WriteFunc func(path string, data map[string]interface{}) (*api.Secret, error)

	// calls tracks calls to the methods.
	calls struct {
		// Read holds details about calls to the Read method.
		Read []struct {
			// Path is the path argument value.
			Path string
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// Path is the path argument value.
			Path string
			// Data is the data argument value.
			Data map[string]interface{}
		}
	}
}

// Read calls ReadFunc.
func (mock *VaultLogicalAPIMock) Read(path string) (*api.Secret, error) {
	if mock.ReadFunc == nil {
		panic("VaultLogicalAPIMock.ReadFunc: method is nil but VaultLogicalAPI.Read was just called")
	}
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	lockVaultLogicalAPIMockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	lockVaultLogicalAPIMockRead.Unlock()
	return mock.ReadFunc(path)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//     len(mockedVaultLogicalAPI.ReadCalls())
func (mock *VaultLogicalAPIMock) ReadCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	lockVaultLogicalAPIMockRead.RLock()
	calls = mock.calls.Read
	lockVaultLogicalAPIMockRead.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *VaultLogicalAPIMock) Write(path string, data map[string]interface{}) (*api.Secret, error) {
	if mock.WriteFunc == nil {
		panic("VaultLogicalAPIMock.WriteFunc: method is nil but VaultLogicalAPI.Write was just called")
	}
	callInfo := struct {
		Path string
		Data map[string]interface{}
	}{
		Path: path,
		Data: data,
	}
	lockVaultLogicalAPIMockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	lockVaultLogicalAPIMockWrite.Unlock()
	return mock.WriteFunc(path, data)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//     len(mockedVaultLogicalAPI.WriteCalls())
func (mock *VaultLogicalAPIMock) WriteCalls() []struct {
	Path string
	Data map[string]interface{}
} {
	var calls []struct {
		Path string
		Data map[string]interface{}
	}
	lockVaultLogicalAPIMockWrite.RLock()
	calls = mock.calls.Write
	lockVaultLogicalAPIMockWrite.RUnlock()
	return calls
}

var (
	lockVaultMountsAPIMockListMounts sync.RWMutex
	lockVaultMountsAPIMockMount      sync.RWMutex
)

// Ensure, that VaultMountsAPIMock does implement VaultMountsAPI.
// If this is not the case, regenerate this file with moq.
var _ VaultMountsAPI = &VaultMountsAPIMock{}

// VaultMountsAPIMock is a mock implementation of VaultMountsAPI.
//
//     func TestSomethingThatUsesVaultMountsAPI(t *testing.T) {
//
//         // make and configure a mocked VaultMountsAPI
//         mockedVaultMountsAPI := &VaultMountsAPIMock{
//             ListMountsFunc: func() (map[string]*api.MountOutput, error) {
// 	               panic("mock out the ListMounts method")
//             },
//             MountFunc: func(path string, mountInfo *api.MountInput) error {
// 	               panic("mock out the Mount method")
//             },
//         }
//
//         // use mockedVaultMountsAPI in code that requires VaultMountsAPI
//         // and then make assertions.
//
//     }
type VaultMountsAPIMock struct {
	// ListMountsFunc mocks the ListMounts method.
	ListMountsFunc func() (map[string]*api.MountOutput, error)

	// MountFunc mocks the Mount method.
	MountFunc func(path string, mountInfo *api.MountInput) error

	// calls tracks calls to the methods.
	calls struct {
		// ListMounts holds details about calls to the ListMounts method.
		ListMounts []struct {
		}
		// Mount holds details about calls to the Mount method.
		Mount []struct {
			// Path is the path argument value.
			Path string
			// MountInfo is the mountInfo argument value.
			MountInfo *api.MountInput
		}
	}
}

// ListMounts calls ListMountsFunc.
func (mock *VaultMountsAPIMock) ListMounts() (map[string]*api.MountOutput, error) {
	if mock.ListMountsFunc == nil {
		panic("VaultMountsAPIMock.ListMountsFunc: method is nil but VaultMountsAPI.ListMounts was just called")
	}
	callInfo := struct {
	}{}
	lockVaultMountsAPIMockListMounts.Lock()
	mock.calls.ListMounts = append(mock.calls.ListMounts, callInfo)
	lockVaultMountsAPIMockListMounts.Unlock()
	return mock.ListMountsFunc()
}

// ListMountsCalls gets all the calls that were made to ListMounts.
// Check the length with:
//     len(mockedVaultMountsAPI.ListMountsCalls())
func (mock *VaultMountsAPIMock) ListMountsCalls() []struct {
} {
	var calls []struct {
	}
	lockVaultMountsAPIMockListMounts.RLock()
	calls = mock.calls.ListMounts
	lockVaultMountsAPIMockListMounts.RUnlock()
	return calls
}

// Mount calls MountFunc.
func (mock *VaultMountsAPIMock) Mount(path string, mountInfo *api.MountInput) error {
	if mock.MountFunc == nil {
		panic("VaultMountsAPIMock.MountFunc: method is nil but VaultMountsAPI.Mount was just called")
	}
	callInfo := struct {
		Path      string
		MountInfo *api.MountInput
	}{
		Path:      path,
		MountInfo: mountInfo,
	}
	lockVaultMountsAPIMockMount.Lock()
	mock.calls.Mount = append(mock.calls.Mount, callInfo)
	lockVaultMountsAPIMockMount.Unlock()
	return mock.MountFunc(path, mountInfo)
}

// MountCalls gets all the calls that were made to Mount.
// Check the length with:
//     len(mockedVaultMountsAPI.MountCalls())
func (mock *VaultMountsAPIMock) MountCalls() []struct {
	Path      string
	MountInfo *api.MountInput
} {
	var calls []struct {
		Path      string
		MountInfo *api.MountInput
	}
	lockVaultMountsAPIMockMount.RLock()
	calls = mock.calls.Mount
	lockVaultMountsAPIMockMount.RUnlock()
	return calls
}
